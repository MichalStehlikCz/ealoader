/*
 * This file is generated by jOOQ.
 */
package com.provys.ealoader.catalogue.db.tables;


import com.provys.ealoader.catalogue.db.Indexes;
import com.provys.ealoader.catalogue.db.Ker;
import com.provys.ealoader.catalogue.db.Keys;
import com.provys.ealoader.catalogue.db.tables.records.KerRelTbRecord;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.List;

import javax.annotation.Generated;

import org.jooq.Field;
import org.jooq.ForeignKey;
import org.jooq.Index;
import org.jooq.Name;
import org.jooq.Record;
import org.jooq.Schema;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.UniqueKey;
import org.jooq.impl.DSL;
import org.jooq.impl.TableImpl;


/**
 * Relations (catalogue)
 */
@Generated(
    value = {
        "http://www.jooq.org",
        "jOOQ version:3.11.7"
    },
    comments = "This class is generated by jOOQ"
)
@SuppressWarnings({ "all", "unchecked", "rawtypes" })
public class KerRelTb extends TableImpl<KerRelTbRecord> {

    private static final long serialVersionUID = 56152081;

    /**
     * The reference instance of <code>KER.KER_REL_TB</code>
     */
    public static final KerRelTb KER_REL_TB = new KerRelTb();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<KerRelTbRecord> getRecordType() {
        return KerRelTbRecord.class;
    }

    /**
     * The column <code>KER.KER_REL_TB.REL_ID</code>. UID
     */
    public final TableField<KerRelTbRecord, Long> REL_ID = createField("REL_ID", org.jooq.impl.SQLDataType.BIGINT.nullable(false), this, "UID");

    /**
     * The column <code>KER.KER_REL_TB.RELTYPE</code>. Relation type (S=simple, M=MN-relation implemented through table, F=free)
     */
    public final TableField<KerRelTbRecord, String> RELTYPE = createField("RELTYPE", org.jooq.impl.SQLDataType.CHAR(1).nullable(false), this, "Relation type (S=simple, M=MN-relation implemented through table, F=free)");

    /**
     * The column <code>KER.KER_REL_TB.NAME_NM</code>. Internal name (identification) of relation
     */
    public final TableField<KerRelTbRecord, String> NAME_NM = createField("NAME_NM", org.jooq.impl.SQLDataType.VARCHAR(200).nullable(false), this, "Internal name (identification) of relation");

    /**
     * The column <code>KER.KER_REL_TB.ISCUSTOM</code>. Relation is custom for actual installation
     */
    public final TableField<KerRelTbRecord, String> ISCUSTOM = createField("ISCUSTOM", org.jooq.impl.SQLDataType.CHAR(1).nullable(false).defaultValue(org.jooq.impl.DSL.field("'N' ", org.jooq.impl.SQLDataType.CHAR)), this, "Relation is custom for actual installation");

    /**
     * The column <code>KER.KER_REL_TB.NAME</code>. Name of relation as entity -&gt; name -&gt; toentity (used in develop lang)
     */
    public final TableField<KerRelTbRecord, String> NAME = createField("NAME", org.jooq.impl.SQLDataType.VARCHAR(200).nullable(false), this, "Name of relation as entity -> name -> toentity (used in develop lang)");

    /**
     * The column <code>KER.KER_REL_TB.TONAME</code>. Name of relation as toentity -&gt; name -&gt; entity (used in develop lang)
     */
    public final TableField<KerRelTbRecord, String> TONAME = createField("TONAME", org.jooq.impl.SQLDataType.VARCHAR(200), this, "Name of relation as toentity -> name -> entity (used in develop lang)");

    /**
     * The column <code>KER.KER_REL_TB.ENTITY_ID</code>. UID of entity relation belongs to (entity with resulting UIDs)
     */
    public final TableField<KerRelTbRecord, BigInteger> ENTITY_ID = createField("ENTITY_ID", org.jooq.impl.SQLDataType.DECIMAL_INTEGER.precision(38).nullable(false), this, "UID of entity relation belongs to (entity with resulting UIDs)");

    /**
     * The column <code>KER.KER_REL_TB.TOENTITY_ID</code>. UID of entity queried (entity with source UIDs)
     */
    public final TableField<KerRelTbRecord, BigInteger> TOENTITY_ID = createField("TOENTITY_ID", org.jooq.impl.SQLDataType.DECIMAL_INTEGER.precision(38), this, "UID of entity queried (entity with source UIDs)");

    /**
     * The column <code>KER.KER_REL_TB.COLUMN_NM</code>. Name of column in entity's table_nm
     */
    public final TableField<KerRelTbRecord, String> COLUMN_NM = createField("COLUMN_NM", org.jooq.impl.SQLDataType.VARCHAR(60), this, "Name of column in entity's table_nm");

    /**
     * The column <code>KER.KER_REL_TB.TOCOLUMN_NM</code>. Name of column in toentity's table_nm
     */
    public final TableField<KerRelTbRecord, String> TOCOLUMN_NM = createField("TOCOLUMN_NM", org.jooq.impl.SQLDataType.VARCHAR(60), this, "Name of column in toentity's table_nm");

    /**
     * The column <code>KER.KER_REL_TB.MNTABLE_NM</code>. Name of MN-decomposition view / table (for internal access)
     */
    public final TableField<KerRelTbRecord, String> MNTABLE_NM = createField("MNTABLE_NM", org.jooq.impl.SQLDataType.VARCHAR(60), this, "Name of MN-decomposition view / table (for internal access)");

    /**
     * The column <code>KER.KER_REL_TB.MNVIEW_NM</code>. Name of MN-decomposition view / table (for client)
     */
    public final TableField<KerRelTbRecord, String> MNVIEW_NM = createField("MNVIEW_NM", org.jooq.impl.SQLDataType.VARCHAR(60), this, "Name of MN-decomposition view / table (for client)");

    /**
     * The column <code>KER.KER_REL_TB.MNCOLUMN_NM</code>. Name of column in MN-decomposition view, coresponding to entity
     */
    public final TableField<KerRelTbRecord, String> MNCOLUMN_NM = createField("MNCOLUMN_NM", org.jooq.impl.SQLDataType.VARCHAR(60), this, "Name of column in MN-decomposition view, coresponding to entity");

    /**
     * The column <code>KER.KER_REL_TB.MNTOCOLUMN_NM</code>. Name of column in MN-decomposition view, coresponding to toentity
     */
    public final TableField<KerRelTbRecord, String> MNTOCOLUMN_NM = createField("MNTOCOLUMN_NM", org.jooq.impl.SQLDataType.VARCHAR(60), this, "Name of column in MN-decomposition view, coresponding to toentity");

    /**
     * The column <code>KER.KER_REL_TB.FK</code>. If column_nm is key_nm (in table_nm for entity), this flag identifies if UIDs in tocolumn are to be checked for type by selecting from entity's table_nm
     */
    public final TableField<KerRelTbRecord, String> FK = createField("FK", org.jooq.impl.SQLDataType.CHAR(1).nullable(false).defaultValue(org.jooq.impl.DSL.field("'N' ", org.jooq.impl.SQLDataType.CHAR)), this, "If column_nm is key_nm (in table_nm for entity), this flag identifies if UIDs in tocolumn are to be checked for type by selecting from entity's table_nm");

    /**
     * The column <code>KER.KER_REL_TB.TBINFREECOND_CD</code>. Template for IN-variant of condition (for internal access)
     */
    public final TableField<KerRelTbRecord, String> TBINFREECOND_CD = createField("TBINFREECOND_CD", org.jooq.impl.SQLDataType.VARCHAR(4000), this, "Template for IN-variant of condition (for internal access)");

    /**
     * The column <code>KER.KER_REL_TB.TBEXFREECOND_CD</code>. Template for EXISTS variant of condition (for internal access)
     */
    public final TableField<KerRelTbRecord, String> TBEXFREECOND_CD = createField("TBEXFREECOND_CD", org.jooq.impl.SQLDataType.VARCHAR(4000), this, "Template for EXISTS variant of condition (for internal access)");

    /**
     * The column <code>KER.KER_REL_TB.VWINFREECOND_CD</code>. Template for IN-variant of condition (for client)
     */
    public final TableField<KerRelTbRecord, String> VWINFREECOND_CD = createField("VWINFREECOND_CD", org.jooq.impl.SQLDataType.VARCHAR(4000), this, "Template for IN-variant of condition (for client)");

    /**
     * The column <code>KER.KER_REL_TB.VWEXFREECOND_CD</code>. Template for EXISTS variant of condition (for client)
     */
    public final TableField<KerRelTbRecord, String> VWEXFREECOND_CD = createField("VWEXFREECOND_CD", org.jooq.impl.SQLDataType.VARCHAR(4000), this, "Template for EXISTS variant of condition (for client)");

    /**
     * The column <code>KER.KER_REL_TB.RECURSIVE</code>. NULL - not recursive; T - transitive closure; R - transitive and recursive closure; meaningful only for simple SELF to SELF relations
     */
    public final TableField<KerRelTbRecord, String> RECURSIVE = createField("RECURSIVE", org.jooq.impl.SQLDataType.CHAR(1), this, "NULL - not recursive; T - transitive closure; R - transitive and recursive closure; meaningful only for simple SELF to SELF relations");

    /**
     * The column <code>KER.KER_REL_TB.CASCXMLEXPORT</code>. Defines how is relation supported in XML exports - N value means no support, Y - included by default, NULL - supported but not included by default. If relation is marked as supported, it means that source objects are / can be included in target entitys XML file.
     */
    public final TableField<KerRelTbRecord, String> CASCXMLEXPORT = createField("CASCXMLEXPORT", org.jooq.impl.SQLDataType.CHAR(1).defaultValue(org.jooq.impl.DSL.field("'N'", org.jooq.impl.SQLDataType.CHAR)), this, "Defines how is relation supported in XML exports - N value means no support, Y - included by default, NULL - supported but not included by default. If relation is marked as supported, it means that source objects are / can be included in target entitys XML file.");

    /**
     * The column <code>KER.KER_REL_TB.ATTREQUIVALENCE</code>. Defines, that some attributes have the same value on both sides of the relation. It is utilized by XML exports/imports.
The form is e.g:  A=B;C;D.E=F
  when the ralation is from entity E1 to entity E2, that means:
    E1.A has the same value as E2.B
    E1.C has the same value as E2.C
    when E1.D is foreign key to entity with composite natural key, it means that
      component E of the key has the same value as E2.F.
      Warning: something like G=H.K is NOT allowed.
     */
    public final TableField<KerRelTbRecord, String> ATTREQUIVALENCE = createField("ATTREQUIVALENCE", org.jooq.impl.SQLDataType.VARCHAR(4000), this, "Defines, that some attributes have the same value on both sides of the relation. It is utilized by XML exports/imports.\nThe form is e.g:  A=B;C;D.E=F\n  when the ralation is from entity E1 to entity E2, that means:\n    E1.A has the same value as E2.B\n    E1.C has the same value as E2.C\n    when E1.D is foreign key to entity with composite natural key, it means that\n      component E of the key has the same value as E2.F.\n      Warning: something like G=H.K is NOT allowed.");

    /**
     * Create a <code>KER.KER_REL_TB</code> table reference
     */
    public KerRelTb() {
        this(DSL.name("KER_REL_TB"), null);
    }

    /**
     * Create an aliased <code>KER.KER_REL_TB</code> table reference
     */
    public KerRelTb(String alias) {
        this(DSL.name(alias), KER_REL_TB);
    }

    /**
     * Create an aliased <code>KER.KER_REL_TB</code> table reference
     */
    public KerRelTb(Name alias) {
        this(alias, KER_REL_TB);
    }

    private KerRelTb(Name alias, Table<KerRelTbRecord> aliased) {
        this(alias, aliased, null);
    }

    private KerRelTb(Name alias, Table<KerRelTbRecord> aliased, Field<?>[] parameters) {
        super(alias, null, aliased, parameters, DSL.comment("Relations (catalogue)"));
    }

    public <O extends Record> KerRelTb(Table<O> child, ForeignKey<O, KerRelTbRecord> key) {
        super(child, key, KER_REL_TB);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Schema getSchema() {
        return Ker.KER;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<Index> getIndexes() {
        return Arrays.<Index>asList(Indexes.KER_REL_ENTITY_IX, Indexes.KER_REL_NAME_UK, Indexes.KER_REL_NM_UK, Indexes.KER_REL_PK, Indexes.KER_REL_TOENTITY_IX);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public UniqueKey<KerRelTbRecord> getPrimaryKey() {
        return Keys.KER_REL_PK;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<UniqueKey<KerRelTbRecord>> getKeys() {
        return Arrays.<UniqueKey<KerRelTbRecord>>asList(Keys.KER_REL_PK, Keys.KER_REL_NM_UK, Keys.KER_REL_NAME_UK);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<ForeignKey<KerRelTbRecord, ?>> getReferences() {
        return Arrays.<ForeignKey<KerRelTbRecord, ?>>asList(Keys.KER_REL_ENTITY_FK, Keys.KER_REL_TOENTITY_FK);
    }

    public KerEntityTb kerRelEntityFk() {
        return new KerEntityTb(this, Keys.KER_REL_ENTITY_FK);
    }

    public KerEntityTb kerRelToentityFk() {
        return new KerEntityTb(this, Keys.KER_REL_TOENTITY_FK);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public KerRelTb as(String alias) {
        return new KerRelTb(DSL.name(alias), this);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public KerRelTb as(Name alias) {
        return new KerRelTb(alias, this);
    }

    /**
     * Rename this table
     */
    @Override
    public KerRelTb rename(String name) {
        return new KerRelTb(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public KerRelTb rename(Name name) {
        return new KerRelTb(name, null);
    }
}
